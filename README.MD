Сначала происходит загрузка класса - создание класса из бинарного представления.
Корневой загрузчик - bootstrap, каждый загрузчик делегирует права на поиск своему родителю, прежде чем искать самому.
Загрузчик классов сначала проверяет, не загружал ли он данный класс ранее.
Если да, то вернет тот класс, который лежит в кэше, если нет, то делегирует родителю.
Потом метаданые класса кладутся в область памяти metaspace.
Далее начинается этап линковки - верификация байт кода - выделение памяти под статические поля и их ининциализация.
В момент вызова метода создаётся фрейм в стеке.
1. берем число 1 и кладём в стек в виде фрейма - сохраняем число в переменную 1 стека метода, положить в стек переменую.
2. создание объекта в куче(heap) в поколение young generation - кладётся ссылка на обект в стек в виде фрейма.
3. аналогично 2
4. создается фрейм и кладётся на вершину стека - создаётся 2 объекта в куче и их ссылки кладутся в стек
 и ещё число кладётся в стек.
5. аналогично 2
6. создаётся новый фрейм в стеке  куда передадим ссылку ii, o и поскольку метод завершил выполнение 
он удаляется из памяти.
7. создаётся новый фрейм в стеке, после чего main() удаляется из памяти.

В куче работает GC, если создать много объектов и в области кучи eden нет места, происходит малая сборка мусора - 
очищает eden  и кладёт выживших в survivor 0. Если Eden  снова переполняется, ситуация повторяется с survivor 0,
пережившие чистку кладутся в survivor 1. После определеного порога выжившие падают в  tenured.
Если переполняется  tenured то происходит полная сборка мусора.