Сначала происходит загрузка класса - создание класса из бинарного представления.
Корневой загрузчик - bootstrap, каждый загрузчик делегирует права на поиск своему родителю, прежде чем искать самому.
Загрузчик классов сначала проверяет, не загружал ли он данный класс ранее.
Если да, то вернет тот класс, который лежит в кэше, если нет, то делегирует родителю.
Потом метаданые класса кладутся в область памяти metaspace.
Далее начинается этап линковки - верификация байт кода - выделение памяти под статические поля и их ининциализация.
В момент вызова метода создаётся фрейм в стеке.
1. берем число 1 и кладём в фрейма стека - сохраняем число в переменную 1 стека метода, положить в стек переменую.
2. создание объекта в куче(heap) в поколение young generation - кладётся ссылка на обект в фрейма стека.
3. аналогично 2
4. создается фрейм и кладётся на вершину стека - береём ссылки из фрейма метода main и передаём их методу.
5. аналогично 2
6. происходят вычисления и конкатенация строки, создаётся новый фрейм в стеке  куда передадим полученную ранее строку и при выходе из него удаляется фрейм в стеке.
7. создаётся новый фрейм в стеке, после чего фрейм main удаляется из стека .

В куче работает GC, если создать много объектов и в области кучи eden нет места, происходит малая сборка мусора - 
очищает eden  и кладёт выживших в survivor 0. Если Eden  снова переполняется, ситуация повторяется с survivor 0,
пережившие чистку кладутся в survivor 1. После определеного порога выжившие падают в  tenured.
Если переполняется  tenured то происходит полная сборка мусора.
